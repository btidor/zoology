#!/usr/bin/env python3
"""A command-line interface for testing and debugging."""

import argparse
import json
import sys

from zbitvector import Solver

from bytes import Bytes
from compiler import compile, symbolic_transaction
from disassembler import abiencode, decode_instruction, disassemble
from snapshot import (
    COUNT,
    LEVEL_FACTORIES,
    Snapshot,
    download_contract,
    snapshot_contracts,
)
from vm import execute


def _disassemble(code: bytes) -> None:
    """Disassemble the given bytecode."""
    offset = 0
    while offset < len(code):
        assert (ins := decode_instruction(code, offset))
        print(str(ins))

        offset += ins.size

        if ins.name == "INVALID":
            break


def _compile(code: bytes) -> None:
    """Compile the given bytecode."""
    program = disassemble(Bytes(code))
    for term in compile(program):
        prefix = "*" if term.storage else "-"
        line = f"{prefix} {term.path.px().ljust(12)} "

        solver = Solver()
        solver.add(term.path.constraint)
        if not solver.check():
            print(f"{line}UNREACHABLE")
            continue
        term.path.narrow(solver)

        calldata = symbolic_transaction().calldata.evaluate(solver).hex()
        prefix, calldata = calldata[:8], calldata[8:]
        line += prefix
        while calldata:
            part, calldata = calldata[:64], calldata[64:]
            line = f"{line} {part}"
        print(line)

        line = "  " + ("RETURN" if term.success else "REVERT").ljust(12)
        returndata = term.returndata.evaluate(solver).hex()
        if not term.success:
            prefix, returndata = returndata[:8], returndata[8:]
        else:
            prefix = "        "
        print(f"{line} {prefix} {returndata}")


def _execute(code: bytes, calldata: bytes) -> None:
    """Execute the given bytecode."""
    raise NotImplementedError


def _snapshot() -> None:
    """Download a snapshot of the Ethernaut CTF contracts."""
    snapshot: Snapshot = {}
    for i, address in enumerate(LEVEL_FACTORIES):
        sys.stderr.write(f"Downloading level {i} of {COUNT-1}\n")
        download_contract(snapshot, address)
    print(json.dumps(snapshot, indent=4))


def _load(level: int) -> bytes:
    """Simulate createInstance() to load a given level."""
    factory = LEVEL_FACTORIES[level]
    contracts = snapshot_contracts(factory)
    original = set(contracts.keys())

    input = abiencode("createInstance(address)") + (0xB).to_bytes(32)
    term, contracts = execute(contracts, factory, input, 0)
    assert term.success

    added = [v for k, v in contracts.items() if k not in original]
    assert len(added) == 1
    assert (program := added[0].program.code.reveal()) is not None
    return program


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    cmd = parser.add_subparsers(dest="command")

    dis = cmd.add_parser("disassemble").add_mutually_exclusive_group(required=True)
    dis.add_argument("-l", "--level", type=int)
    dis.add_argument("-c", "--code", type=bytes.fromhex)

    cmp = cmd.add_parser("compile").add_mutually_exclusive_group(required=True)
    cmp.add_argument("-l", "--level", type=int)
    cmp.add_argument("-c", "--code", type=bytes.fromhex)

    exe = cmd.add_parser("execute")
    exg = exe.add_mutually_exclusive_group(required=True)
    exg.add_argument("-l", "--level", type=int)
    exg.add_argument("-c", "--code", type=bytes.fromhex)
    exe.add_argument("-d", "--data", type=bytes.fromhex, required=True)

    snp = cmd.add_parser("snapshot")

    args = parser.parse_args()
    match args.command:
        case "disassemble":
            if args.level is not None:
                code = _load(args.level)
                _disassemble(code)
            else:
                _disassemble(args.code)
        case "compile":
            if args.level is not None:
                code = _load(args.level)
                _compile(code)
            else:
                _compile(args.code)
        case "execute":
            if args.level is not None:
                code = _load(args.level)
                _execute(code, args.data)
            else:
                _execute(args.code, args.data)
        case "snapshot":
            _snapshot()
        case _:
            parser.print_help()
