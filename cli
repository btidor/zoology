#!/usr/bin/env python3
"""A command-line interface for testing and debugging."""

import argparse
import json
import sys

from zbitvector import Solver

from bytes import Bytes
from compiler import compile, symbolic_transaction
from disassembler import abiencode, decode_instruction, disassemble
from snapshot import (
    COUNT,
    LEVEL_FACTORIES,
    Snapshot,
    download_contract,
    snapshot_contracts,
)
from state import Address, Blockchain, Contract
from vm import execute


def _disassemble(code: bytes) -> None:
    """Disassemble the given bytecode."""
    offset = 0
    while offset < len(code):
        assert (ins := decode_instruction(code, offset))
        print(str(ins))

        offset += ins.size

        if ins.name == "INVALID":
            break


def _compile(code: bytes) -> None:
    """Compile the given bytecode."""
    program = disassemble(Bytes(code))
    for term in compile(program):
        prefix = "*" if term.storage else "-"
        line = f"{prefix} {term.path.px().ljust(12)} "

        solver = Solver()
        solver.add(term.path.constraint)
        if not solver.check():
            print(f"{line}UNREACHABLE")
            continue
        term.path.narrow(solver)

        calldata = symbolic_transaction().calldata.evaluate(solver).hex()
        prefix, calldata = calldata[:8], calldata[8:]
        line += prefix
        while calldata:
            part, calldata = calldata[:64], calldata[64:]
            line = f"{line} {part}"
        print(line)

        line = "  " + ("RETURN" if term.success else "REVERT").ljust(12)
        returndata = term.returndata.evaluate(solver).hex()
        if not term.success:
            prefix, returndata = returndata[:8], returndata[8:]
        else:
            prefix = "        "
        print(f"{line} {prefix} {returndata}")


def _execute(lc: int | bytes, calldata: bytes) -> None:
    """Execute the given bytecode."""
    if isinstance(lc, int):
        k, address = __load(lc)
    else:
        k = Blockchain()
        address = Address(0x1234)
        k.contracts[address] = Contract(disassemble(Bytes(lc)))

    term, k = execute(k, address, calldata)
    print("RETURN" if term.success else "REVERT", end=" ")
    solver = Solver()
    solver.add(term.path.constraint)
    assert solver.check()
    term.path.narrow(solver)
    print(term.returndata.evaluate(solver).hex())


def _snapshot() -> None:
    """Download a snapshot of the Ethernaut CTF contracts."""
    snapshot: Snapshot = {}
    for i, address in enumerate(LEVEL_FACTORIES):
        sys.stderr.write(f"Downloading level {i} of {COUNT-1}\n")
        download_contract(snapshot, address)
    print(json.dumps(snapshot, indent=4))


def _load(level: int) -> bytes:
    """Simulate createInstance() to load a given level."""
    k, address = __load(level)
    code = k.contracts[address].program.code.reveal()
    assert code is not None
    return code


def __load(level: int) -> tuple[Blockchain, Address]:
    factory = LEVEL_FACTORIES[level]
    k = snapshot_contracts(factory)
    original = set(k.contracts.keys())

    input = abiencode("createInstance(address)") + (0xB).to_bytes(32)
    term, k = execute(k, factory, input, 0)
    assert term.success

    added = [k for k in k.contracts.keys() if k not in original]
    assert len(added) == 1
    return k, added[0]


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    cmd = parser.add_subparsers(dest="command")

    cod = cmd.add_parser("code")
    cod.add_argument("-l", "--level", type=int, required=True)

    dis = cmd.add_parser("disassemble").add_mutually_exclusive_group(required=True)
    dis.add_argument("-l", "--level", type=int)
    dis.add_argument("-c", "--code", type=bytes.fromhex)

    cmp = cmd.add_parser("compile").add_mutually_exclusive_group(required=True)
    cmp.add_argument("-l", "--level", type=int)
    cmp.add_argument("-c", "--code", type=bytes.fromhex)

    exe = cmd.add_parser("execute")
    exg = exe.add_mutually_exclusive_group(required=True)
    exg.add_argument("-l", "--level", type=int)
    exg.add_argument("-c", "--code", type=bytes.fromhex)
    exe.add_argument("-d", "--data", type=bytes.fromhex, required=True)

    snp = cmd.add_parser("snapshot")

    args = parser.parse_args()
    match args.command:
        case "code":
            code = _load(args.level)
            print(code.hex())
        case "disassemble":
            if args.level is not None:
                code = _load(args.level)
                _disassemble(code)
            else:
                _disassemble(args.code)
        case "compile":
            if args.level is not None:
                code = _load(args.level)
                _compile(code)
            else:
                _compile(args.code)
        case "execute":
            if args.level is not None:
                _execute(args.level, args.data)
            else:
                _execute(args.code, args.data)
        case "snapshot":
            _snapshot()
        case _:
            parser.print_help()
